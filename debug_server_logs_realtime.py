#!/usr/bin/env python3
"""
Debug dos logs do servidor em tempo real
Monitora exatamente onde est√° falhando a gera√ß√£o de √°udio
"""

import requests
import time
import logging
import json
import threading
import subprocess
import os
from datetime import datetime

# Configurar logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class ServerLogMonitor:
    """Monitor de logs do servidor em tempo real"""
    
    def __init__(self):
        self.base_url = "http://localhost:8001"
        self.monitoring = False
        
    def check_server_status(self):
        """Verifica status detalhado do servidor"""
        logger.info("üîç VERIFICANDO STATUS DETALHADO DO SERVIDOR")
        logger.info("=" * 60)
        
        try:
            # Health check
            response = requests.get(f"{self.base_url}/health", timeout=10)
            if response.status_code == 200:
                data = response.json()
                logger.info("‚úÖ Servidor est√° rodando")
                logger.info(f"üìä Vers√£o: {data.get('version', 'N/A')}")
                
                # Verificar servi√ßos
                services = data.get('services', {})
                tts_service = services.get('tts_service', {})
                
                if tts_service.get('status') == 'healthy':
                    logger.info("‚úÖ Servi√ßo TTS est√° saud√°vel")
                    
                    engines = tts_service.get('engines', {})
                    for engine_name, engine_info in engines.items():
                        status = engine_info.get('status', 'unknown')
                        available = engine_info.get('available', False)
                        logger.info(f"üé≠ {engine_name}: Status={status}, Dispon√≠vel={available}")
                        
                        if engine_name == 'xtts_v2' and not available:
                            logger.error("‚ùå XTTS v2 n√£o est√° dispon√≠vel!")
                        elif engine_name == 'xtts_v2' and available:
                            logger.info("‚úÖ XTTS v2 est√° dispon√≠vel")
                else:
                    logger.error("‚ùå Servi√ßo TTS n√£o est√° saud√°vel")
                    
                return True
            else:
                logger.error(f"‚ùå Servidor retornou status: {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erro ao verificar servidor: {e}")
            return False
    
    def test_simple_synthesis(self):
        """Testa s√≠ntese simples para isolar o problema"""
        logger.info("üîÑ TESTE: S√≠ntese simples (n√£o clonagem)")
        
        try:
            payload = {
                "text": "Teste de s√≠ntese simples para debug.",
                "language": "pt"
            }
            
            logger.info(f"üì§ Enviando: {payload}")
            
            response = requests.post(
                f"{self.base_url}/api/tts/synthesize",
                json=payload,
                timeout=60
            )
            
            logger.info(f"üì• Status resposta: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                success = data.get("success", False)
                error = data.get("error", "")
                engine = data.get("engine", "unknown")
                audio_size = len(data.get("audio_base64", ""))
                
                logger.info(f"üìä Success: {success}")
                logger.info(f"üìä Engine: {engine}")
                logger.info(f"üìä Audio size: {audio_size} chars")
                
                if error:
                    logger.error(f"‚ùå Erro: {error}")
                
                if success and audio_size > 0:
                    logger.info("‚úÖ S√≠ntese simples funcionou!")
                    return True
                else:
                    logger.error("‚ùå S√≠ntese simples falhou")
                    return False
            else:
                logger.error(f"‚ùå Resposta HTTP: {response.status_code}")
                logger.error(f"Conte√∫do: {response.text[:500]}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erro na s√≠ntese simples: {e}")
            return False
    
    def test_voice_cloning_detailed(self):
        """Testa clonagem de voz com debug detalhado"""
        logger.info("üîÑ TESTE: Clonagem de voz (debug detalhado)")
        
        try:
            payload = {
                "text": "Este √© um teste detalhado de clonagem de voz para identificar onde est√° falhando exatamente.",
                "language": "pt"
            }
            
            logger.info(f"üì§ Enviando para clonagem: {payload}")
            
            # Fazer requisi√ß√£o com timeout longo
            start_time = time.time()
            response = requests.post(
                f"{self.base_url}/api/tts/clone-voice",
                json=payload,
                timeout=180  # 3 minutos
            )
            end_time = time.time()
            
            duration = end_time - start_time
            logger.info(f"üì• Status resposta: {response.status_code}")
            logger.info(f"‚è±Ô∏è Tempo de resposta: {duration:.2f}s")
            
            if response.status_code == 200:
                try:
                    data = response.json()
                    success = data.get("success", False)
                    error = data.get("error", "")
                    engine = data.get("engine", "unknown")
                    message = data.get("message", "")
                    audio_size = len(data.get("audio_base64", ""))
                    
                    logger.info(f"üìä Success: {success}")
                    logger.info(f"üìä Engine: {engine}")
                    logger.info(f"üìä Message: {message}")
                    logger.info(f"üìä Audio size: {audio_size} chars")
                    
                    if error:
                        logger.error(f"‚ùå Erro detalhado: {error}")
                        
                        # Analisar tipo de erro
                        error_lower = error.lower()
                        if "reference" in error_lower:
                            logger.error("üîç PROBLEMA: Arquivo de refer√™ncia")
                        elif "mecab" in error_lower:
                            logger.error("üîç PROBLEMA: MeCab")
                        elif "memory" in error_lower:
                            logger.error("üîç PROBLEMA: Mem√≥ria")
                        elif "cuda" in error_lower or "gpu" in error_lower:
                            logger.error("üîç PROBLEMA: GPU/CUDA")
                        elif "base64" in error_lower:
                            logger.error("üîç PROBLEMA: Convers√£o base64")
                        elif "invalid file" in error_lower:
                            logger.error("üîç PROBLEMA: Arquivo inv√°lido")
                        else:
                            logger.error("üîç PROBLEMA: Desconhecido")
                    
                    if success and audio_size > 0:
                        logger.info("‚úÖ Clonagem funcionou!")
                        
                        # Testar se √°udio √© v√°lido
                        try:
                            import base64
                            audio_data = base64.b64decode(data.get("audio_base64", ""))
                            if len(audio_data) > 1000:  # Pelo menos 1KB
                                logger.info(f"‚úÖ √Åudio v√°lido: {len(audio_data)} bytes")
                                return True
                            else:
                                logger.error(f"‚ùå √Åudio muito pequeno: {len(audio_data)} bytes")
                                return False
                        except Exception as decode_error:
                            logger.error(f"‚ùå Erro ao decodificar √°udio: {decode_error}")
                            return False
                    else:
                        logger.error("‚ùå Clonagem falhou - sem √°udio gerado")
                        return False
                        
                except json.JSONDecodeError as json_error:
                    logger.error(f"‚ùå Erro JSON: {json_error}")
                    logger.error(f"Resposta raw: {response.text[:1000]}")
                    return False
                    
            else:
                logger.error(f"‚ùå Resposta HTTP: {response.status_code}")
                logger.error(f"Conte√∫do: {response.text[:500]}")
                
                if response.status_code == 404:
                    logger.error("üîç PROBLEMA: Endpoint n√£o encontrado")
                elif response.status_code == 500:
                    logger.error("üîç PROBLEMA: Erro interno do servidor")
                elif response.status_code == 422:
                    logger.error("üîç PROBLEMA: Dados inv√°lidos")
                
                return False
                
        except requests.exceptions.Timeout:
            logger.error("‚ùå TIMEOUT: Clonagem demorou mais de 3 minutos")
            logger.error("üîç PROBLEMA: Processo muito lento ou travado")
            return False
        except Exception as e:
            logger.error(f"‚ùå Erro na clonagem: {e}")
            logger.error(f"üîç Tipo do erro: {type(e).__name__}")
            return False
    
    def run_comprehensive_test(self):
        """Executa teste abrangente"""
        logger.info("üß™ INICIANDO TESTE ABRANGENTE DO SERVIDOR")
        logger.info("=" * 70)
        
        tests_passed = 0
        total_tests = 3
        
        # Teste 1: Status do servidor
        if self.check_server_status():
            tests_passed += 1
            logger.info("‚úÖ TESTE 1 PASSOU: Status do servidor")
        else:
            logger.error("‚ùå TESTE 1 FALHOU: Status do servidor")
            return
        
        # Teste 2: S√≠ntese simples
        if self.test_simple_synthesis():
            tests_passed += 1
            logger.info("‚úÖ TESTE 2 PASSOU: S√≠ntese simples")
        else:
            logger.error("‚ùå TESTE 2 FALHOU: S√≠ntese simples")
        
        # Teste 3: Clonagem de voz
        if self.test_voice_cloning_detailed():
            tests_passed += 1
            logger.info("‚úÖ TESTE 3 PASSOU: Clonagem de voz")
        else:
            logger.error("‚ùå TESTE 3 FALHOU: Clonagem de voz")
        
        # Resultado final
        logger.info("=" * 70)
        logger.info("üìä RESULTADO FINAL DO DEBUG")
        logger.info("=" * 70)
        
        if tests_passed == total_tests:
            logger.info("üéâ TODOS OS TESTES PASSARAM!")
            logger.info("‚úÖ Sistema est√° funcionando corretamente")
            print("\nüéØ DIAGN√ìSTICO: Sistema OK")
            
        elif tests_passed == 2:
            logger.warning("‚ö†Ô∏è S√çNTESE FUNCIONA, CLONAGEM FALHA")
            logger.info("‚úÖ Servidor e s√≠ntese simples funcionam")
            logger.error("‚ùå Problema espec√≠fico na clonagem de voz")
            
            print("\nüîç DIAGN√ìSTICO:")
            print("‚úÖ Servidor est√° funcionando")
            print("‚úÖ S√≠ntese simples funciona")
            print("‚ùå PROBLEMA: Clonagem de voz")
            print("üí° Verifique XTTS v2 ou arquivos de refer√™ncia")
            
        elif tests_passed == 1:
            logger.warning("‚ö†Ô∏è APENAS STATUS FUNCIONA")
            logger.info("‚úÖ Servidor responde")
            logger.error("‚ùå TTS n√£o funciona (nem s√≠ntese nem clonagem)")
            
            print("\nüîç DIAGN√ìSTICO:")
            print("‚úÖ Servidor conecta")
            print("‚ùå PROBLEMA: TTS n√£o funciona")
            print("üí° Verifique engines TTS")
            print("üí° Verifique depend√™ncias")
            
        else:
            logger.error("‚ùå TODOS OS TESTES FALHARAM")
            logger.error("‚ùå Servidor n√£o est√° funcionando")
            
            print("\nüîç DIAGN√ìSTICO:")
            print("‚ùå PROBLEMA: Servidor n√£o funciona")
            print("üí° Verifique se servidor est√° rodando")
            print("üí° Execute: start_enhanced_correct.bat")

def main():
    """Fun√ß√£o principal"""
    print("üîç DEBUG DOS LOGS DO SERVIDOR EM TEMPO REAL")
    print("Este script monitora exatamente onde est√° falhando a gera√ß√£o de √°udio")
    print("=" * 80)
    
    monitor = ServerLogMonitor()
    monitor.run_comprehensive_test()
    
    print("\nüí° PR√ìXIMOS PASSOS:")
    print("1. Se s√≠ntese simples falha ‚Üí Problema nos engines TTS")
    print("2. Se clonagem falha ‚Üí Problema no XTTS v2 ou refer√™ncia")
    print("3. Se tudo falha ‚Üí Problema no servidor")
    
    print("\nüîß PARA CORRIGIR:")
    print("- Reinicie o servidor: start_enhanced_correct.bat")
    print("- Teste com arquivo real: python test_with_real_voice_file.py")
    print("- Verifique logs do servidor no terminal")

if __name__ == "__main__":
    main()